# -*- coding: utf-8 -*-
"""
Extensi√≥n de GradioRAGApp para mostrar capacidades agentic.
Mantiene compatibilidad completa con interfaz existente.
"""

import gradio as gr
from typing import List, Tuple
from src.services.agentic_rag_service import AgenticRAGService, create_rag_service
from src.utils.logger import setup_logger
from config.settings import settings

logger = setup_logger()

class AgenticGradioApp:
    """
    Aplicaci√≥n Gradio extendida con capacidades agentic.
    Mantiene toda la funcionalidad existente.
    """
    
    def __init__(self, enable_agentic: bool = True):
        # Usar factory para crear servicio apropiado
        self.rag_service = create_rag_service(agentic=enable_agentic)
        self.is_agentic = isinstance(self.rag_service, AgenticRAGService)
        self.initialized = False
        
        logger.info(f"AgenticGradioApp created (agentic: {self.is_agentic})")
    
    def initialize_service(self) -> str:
        """Inicializa el servicio RAG con capacidades agentic"""
        try:
            if self.rag_service.initialize():
                self.initialized = True
                
                if self.is_agentic:
                    status = "‚úÖ Sistema RAG Agentic inicializado correctamente"
                    
                    # Obtener estad√≠sticas de agentes
                    agent_stats = self.rag_service.get_agent_stats()
                    if agent_stats["agentic_mode"]:
                        status += f"\nü§ñ Agentes disponibles: {agent_stats['agents_count']}"
                        status += f"\nüß† Memoria distribuida: {'Activa' if agent_stats.get('memory_stats', {}).get('redis_available') else 'Local'}"
                    else:
                        status += "\n‚ö†Ô∏è Modo cl√°sico activo (agentes no disponibles)"
                else:
                    status = "‚úÖ Sistema RAG cl√°sico inicializado correctamente"
                    
                return status
            else:
                return "‚ö†Ô∏è Sistema inicializado pero no se encontraron documentos para indexar"
                
        except Exception as e:
            logger.error(f"Error initializing service: {e}")
            return f"‚ùå Error al inicializar: {str(e)}"
    
    def chat_response(self, message: str, history: List[Tuple[str, str]]) -> str:
        """Maneja respuestas con capacidades agentic"""
        if not self.initialized:
            return "‚ùå El sistema no est√° inicializado. Por favor inicial√≠zalo primero."
        
        if not message.strip():
            return "Por favor, escribe una pregunta."
        
        try:
            # Usar m√©todo agentic si est√° disponible
            if self.is_agentic and hasattr(self.rag_service, 'query_agentic'):
                import asyncio
                try:
                    # Intentar consulta agentic async
                    result = asyncio.run(
                        self.rag_service.query_agentic(message, session_id="gradio_session")
                    )
                except:
                    # Fallback a m√©todo cl√°sico
                    result = self.rag_service.query(message)
            else:
                # M√©todo cl√°sico
                result = self.rag_service.query(message)
            
            response = result['answer']
            
            # Agregar informaci√≥n de agente si est√° disponible
            if self.is_agentic and 'agent_info' in result:
                agent_info = result['agent_info']
                if settings.log_level == "DEBUG":
                    response += f"\n\n*[Procesado por {agent_info.get('agent_name', 'RAG cl√°sico')}"
                    if 'confidence' in agent_info:
                        response += f", confianza: {agent_info['confidence']:.2f}"
                    response += "]*"
            
            # Informaci√≥n de modelo (preservada de versi√≥n original)
            model_info = result.get('model_info', {})
            if model_info and model_info.get('selected_model') and settings.log_level == "DEBUG":
                model_name = model_info.get('selected_model', 'unknown')
                complexity = model_info.get('complexity_score', 0)
                response += f"\n\n*[Modelo: {model_name}, complejidad: {complexity:.2f}]*"
            
            return response
            
        except Exception as e:
            logger.error(f"Error in chat response: {e}")
            return f"‚ùå Error al procesar la pregunta: {str(e)}"
    
    def reindex_documents(self) -> str:
        """Reindexar documentos (m√©todo preservado)"""
        try:
            count = self.rag_service.reindex_documents()
            if count > 0:
                return f"‚úÖ Reindexados {count} documentos correctamente"
            else:
                return "‚ö†Ô∏è No se encontraron documentos para reindexar"
        except Exception as e:
            logger.error(f"Error reindexing: {e}")
            return f"‚ùå Error al reindexar: {str(e)}"
    
    def get_faq_markdown(self) -> str:
        """Genera texto Markdown de preguntas frecuentes (preservado)"""
        if hasattr(self.rag_service, 'get_frequent_questions'):
            faqs = self.rag_service.get_frequent_questions()
            if not faqs:
                return "_No hay preguntas frecuentes registradas a√∫n._"
            lines = "\n".join(f"- {q}" for q in faqs)
            return f"**Preguntas frecuentes:**\n{lines}"
        return "_Funcionalidad no disponible._"
    
    def get_system_status(self) -> str:
        """Obtiene estado detallado del sistema (nueva funcionalidad)"""
        try:
            status = self.rag_service.get_status()
            
            status_text = "### üìä Estado del Sistema\n\n"
            
            # Estado b√°sico
            if status.get('initialized'):
                status_text += "‚úÖ **Sistema**: Inicializado\n"
            else:
                status_text += "‚ùå **Sistema**: No inicializado\n"
            
            status_text += f"üìÅ **Documentos**: {status.get('document_count', 0)} indexados\n"
            
            # Estado agentic si est√° disponible
            if self.is_agentic:
                agentic_mode = status.get('agentic_mode', False)
                status_text += f"ü§ñ **Modo Agentic**: {'Activo' if agentic_mode else 'Inactivo'}\n"
                
                agents = status.get('agents_available', [])
                if agents:
                    status_text += f"üë• **Agentes**: {', '.join(agents)}\n"
                
                # M√©tricas agentic
                metrics = status.get('agentic_metrics', {})
                if metrics:
                    status_text += "\n**üìà M√©tricas Agentic:**\n"
                    status_text += f"- Consultas procesadas por agentes: {metrics.get('agent_queries', 0)}\n"
                    status_text += f"- Fallbacks a RAG cl√°sico: {metrics.get('fallback_to_classic', 0)}\n"
            
            # Configuraci√≥n de modelos
            status_text += "\n**üîß Configuraci√≥n:**\n"
            status_text += f"- Modelo complejo: {settings.complex_model}\n"
            status_text += f"- Modelo simple: {settings.simple_model}\n"
            status_text += f"- Selecci√≥n inteligente: {'Activa' if settings.enable_smart_selection else 'Inactiva'}\n"
            
            return status_text
            
        except Exception as e:
            return f"‚ùå Error obteniendo estado: {str(e)}"
    
    def toggle_agentic_mode(self) -> str:
        """Activa/desactiva modo agentic (nueva funcionalidad)"""
        if not self.is_agentic:
            return "‚ö†Ô∏è Servicio no soporta modo agentic"
        
        try:
            current_status = self.rag_service.get_status().get('agentic_mode', False)
            
            if current_status:
                self.rag_service.disable_agentic_mode()
                return "‚úÖ Modo agentic desactivado - usando RAG cl√°sico"
            else:
                self.rag_service.enable_agentic_mode()
                new_status = self.rag_service.get_status().get('agentic_mode', False)
                if new_status:
                    return "‚úÖ Modo agentic activado"
                else:
                    return "‚ùå No se pudo activar modo agentic - verificar inicializaci√≥n"
                    
        except Exception as e:
            return f"‚ùå Error cambiando modo: {str(e)}"
    
    def create_interface(self) -> gr.Blocks:
        """Crea la interfaz extendida con capacidades agentic"""
        with gr.Blocks(
            title="Sistema RAG Agentic - Investigaci√≥n de Tesis",
            theme=gr.themes.Soft(),
        ) as interface:
            
            gr.HTML(f"""
            <div style="text-align: center; margin-bottom: 2rem;">
                <h1>ü§ñ Sistema RAG Agentic para Investigaci√≥n</h1>
                <p>Especializado en IA para Historias de Usuario - {'Con Agentes Especializados' if self.is_agentic else 'Modo Cl√°sico'}</p>
                <p><small>{'Usa agentes especializados para an√°lisis acad√©mico avanzado' if self.is_agentic else 'Usa selecci√≥n inteligente de modelos GPT-4o/4o-mini'}</small></p>
            </div>
            """)
            
            with gr.Tabs():
                # Tab principal - Chat (preservado y mejorado)
                with gr.TabItem("üí¨ Chat Acad√©mico"):
                    gr.Markdown("### Asistente de Investigaci√≥n Agentic" if self.is_agentic else "### Asistente de Investigaci√≥n")
                    if self.is_agentic:
                        gr.Markdown("El sistema seleccionar√° autom√°ticamente el agente m√°s apropiado para tu consulta acad√©mica.")
                    else:
                        gr.Markdown("Haz preguntas acad√©micas sobre tus documentos. El sistema seleccionar√° autom√°ticamente el modelo m√°s apropiado.")
                    
                    # ChatInterface (preservado)
                    chatbot = gr.Chatbot(
                        label="Conversaci√≥n Acad√©mica",
                        height=400,
                        type='messages'
                    )
                    
                    with gr.Row():
                        msg = gr.Textbox(
                            label="Tu pregunta de investigaci√≥n",
                            placeholder="Ej: Compara las metodolog√≠as de IA para historias de usuario...",
                            scale=4
                        )
                        send_btn = gr.Button("Enviar", variant="primary", scale=1)
                    
                    with gr.Row():
                        clear_btn = gr.Button("üóëÔ∏è Limpiar Chat", variant="secondary")
                    
                    # Ejemplos acad√©micos (preservados)
                    gr.Examples(
                        examples=[
                            "¬øCu√°les son las principales metodolog√≠as de IA para mejorar historias de usuario?",
                            "Compara los enfoques de NLP vs Machine Learning en requirements engineering",
                            "¬øQu√© gaps de investigaci√≥n existen en la automatizaci√≥n de historias de usuario?",
                            "Analiza las m√©tricas de evaluaci√≥n utilizadas en la literatura",
                            "¬øQu√© t√©cnicas de deep learning se han aplicado a requirements?",
                            "Resume el estado del arte en IA para desarrollo √°gil",
                        ],
                        inputs=msg
                    )

                    faq_display = gr.Markdown(value=self.get_faq_markdown())
                    
                    def respond(message, chat_history):
                        if not message.strip():
                            return chat_history, "", self.get_faq_markdown()
                        
                        # Obtener respuesta del RAG
                        bot_response = self.chat_response(message, chat_history)
                        
                        # Agregar al historial en formato correcto para Gradio
                        chat_history.append({"role": "user", "content": message})
                        chat_history.append({"role": "assistant", "content": bot_response})

                        return chat_history, "", self.get_faq_markdown()
                    
                    # Event handlers para el chat (preservados)
                    send_btn.click(
                        respond,
                        inputs=[msg, chatbot],
                        outputs=[chatbot, msg, faq_display]
                    )
                    
                    msg.submit(
                        respond,
                        inputs=[msg, chatbot],
                        outputs=[chatbot, msg, faq_display]
                    )
                    
                    clear_btn.click(
                        lambda: ([], "", self.get_faq_markdown()),
                        outputs=[chatbot, msg, faq_display]
                    )
                
                # Tab de administraci√≥n (extendido)
                with gr.TabItem("‚öôÔ∏è Administraci√≥n"):
                    gr.Markdown("### Gesti√≥n del Sistema RAG Agentic" if self.is_agentic else "### Gesti√≥n del Sistema RAG")
                    
                    with gr.Row():
                        init_btn = gr.Button("üöÄ Inicializar Sistema", variant="primary")
                        reindex_btn = gr.Button("üìö Reindexar Documentos", variant="secondary")
                        
                        # Controles agentic adicionales
                        if self.is_agentic:
                            toggle_btn = gr.Button("üîÑ Cambiar Modo", variant="secondary")
                    
                    status_output = gr.Textbox(
                        label="Estado del Sistema",
                        interactive=False,
                        lines=3
                    )
                    
                    # Estado detallado del sistema (nuevo)
                    with gr.Row():
                        status_btn = gr.Button("üìä Ver Estado Detallado", variant="secondary")
                    
                    detailed_status = gr.Markdown(value="Presiona 'Ver Estado Detallado' para m√°s informaci√≥n.")
                    
                    # Configuraci√≥n del sistema (preservada y extendida)
                    gr.Markdown("### Configuraci√≥n Actual")
                    
                    config_text = f"""
                    **Selecci√≥n Inteligente de Modelos:**
                    - üß† **Modelo para consultas complejas**: `{settings.complex_model}`
                    - ‚ö° **Modelo para consultas simples**: `{settings.simple_model}`
                    - üéØ **Umbral de complejidad**: `{settings.complexity_threshold}`
                    - üîÑ **Selecci√≥n autom√°tica**: `{'Activada' if settings.enable_smart_selection else 'Desactivada'}`
                    """
                    
                    if self.is_agentic:
                        config_text += """
                    
                    **Capacidades Agentic:**
                    - ü§ñ **Agentes especializados**: DocumentSearchAgent
                    - üß† **Memoria distribuida**: Redis + ChromaDB
                    - üîÑ **Selecci√≥n autom√°tica de agentes**: Activa
                    - üìä **M√©tricas de agentes**: Disponibles
                        """
                    
                    config_text += f"""
                    
                    **Configuraci√≥n RAG:**
                    - üìÅ **Directorio de documentos**: `{settings.documents_path}`
                    - üóÉÔ∏è **Base de datos vectorial**: `{settings.vector_db_path}`
                    - üî§ **Modelo de embeddings**: `{settings.embedding_model}`
                    - üìä **Tama√±o de chunk**: `{settings.chunk_size}`
                    - üîó **Overlap de chunk**: `{settings.chunk_overlap}`
                    - üìñ **Documentos por consulta**: `{settings.max_documents}`
                    """
                    
                    gr.Markdown(config_text)
                
                # Tab de ayuda acad√©mica (preservado y extendido)
                with gr.TabItem("üìö Gu√≠a de Investigaci√≥n"):
                    if self.is_agentic:
                        gr.Markdown("""
                        ## üéì Sistema RAG Agentic para Investigaci√≥n de Tesis
                        
                        ### ü§ñ Agentes Especializados
                        
                        El sistema utiliza **agentes inteligentes especializados**:
                        
                        **DocumentSearchAgent** se activa autom√°ticamente para:
                        - üî¨ **An√°lisis acad√©mico profundo**: "analiza metodolog√≠a", "compara enfoques"
                        - üìä **B√∫squeda especializada**: "encuentra papers sobre", "literatura en"
                        - üéØ **Extracci√≥n de informaci√≥n**: "qu√© t√©cnicas", "cu√°les son las m√©tricas"
                        - üìù **S√≠ntesis acad√©mica**: "resume el estado del arte", "gaps de investigaci√≥n"
                        
                        ### üß† Memoria Inteligente
                        
                        Los agentes mantienen **memoria de conversaci√≥n**:
                        - üí≠ **Contexto de sesi√≥n**: Recuerdan consultas anteriores
                        - üîó **Conexiones sem√°nticas**: Relacionan preguntas con respuestas pasadas
                        - üìö **Memoria acad√©mica**: Almacenan hallazgos importantes
                        
                        ### üöÄ Estrategias de B√∫squeda Avanzadas
                        
                        El sistema selecciona autom√°ticamente la mejor estrategia:
                        
                        #### **B√∫squeda Acad√©mica** (para an√°lisis profundo)
                        - "Analiza el estado del arte en IA para historias de usuario"
                        - "¬øCu√°les son las metodolog√≠as principales en la literatura?"
                        - "Sintetiza los enfoques de NLP en requirements engineering"
                        
                        #### **B√∫squeda por Metadatos** (para filtros espec√≠ficos)
                        - "Papers del autor Smith en 2020"
                        - "Estudios publicados despu√©s de 2018"
                        - "Art√≠culos de la conferencia ICSE"
                        
                        #### **B√∫squeda por Palabras Clave** (para t√©rminos exactos)
                        - 'Buscar "machine learning" exacto'
                        - "Documentos que mencionen 'user story generation'"
                        - "Papers con 'natural language processing'"
                        
                        #### **B√∫squeda Sem√°ntica** (por defecto)
                        - "T√©cnicas de automatizaci√≥n de requirements"
                        - "Mejoras en el desarrollo √°gil"
                        - "Aplicaciones de IA en software engineering"
                        """)
                    else:
                        gr.Markdown("""
                        ## üéì Sistema RAG para Investigaci√≥n de Tesis
                        
                        ### üß† Selecci√≥n Inteligente de Modelos
                        
                        El sistema **selecciona autom√°ticamente** el modelo m√°s apropiado:
                        
                        **GPT-4o (An√°lisis Complejo)** se activa con:
                        - üî¨ **Palabras acad√©micas**: "analiza", "compara", "eval√∫a", "metodolog√≠a"
                        - üìä **An√°lisis cr√≠tico**: "ventajas y desventajas", "limitaciones", "gaps"
                        - üéØ **Estado del arte**: "literatura", "s√≠ntesis", "framework"
                        - üìù **Investigaci√≥n**: "paper", "estudio", "hallazgos"
                        
                        **GPT-4o-mini (Consultas Simples)** para:
                        - ‚ùì **Definiciones**: "¬øQu√© es...?", "Define..."
                        - üìã **Listas**: "Lista las t√©cnicas...", "Enumera..."
                        - üîç **B√∫squedas b√°sicas**: "Encuentra...", "Busca..."
                        """)
                    
                    gr.Markdown("""
                    ### üí° Consejos para Mejores Resultados
                    
                    1. **S√© espec√≠fico** en tus preguntas acad√©micas
                    2. **Usa terminolog√≠a t√©cnica** para activar an√°lisis profundo
                    3. **Pregunta por comparaciones** para obtener s√≠ntesis complejas
                    4. **Solicita gaps** para identificar oportunidades de investigaci√≥n
                    5. **Pide citas espec√≠ficas** mencionando autores cuando sea posible
                    
                    ### üìñ Preparaci√≥n de Documentos
                    
                    1. **Organiza tus 159 PDFs** por categor√≠as tem√°ticas
                    2. **Procesa por lotes** (20-30 papers a la vez)
                    3. **Verifica nombres** descriptivos de archivos
                    4. **Inicia con papers fundamentales** antes de casos espec√≠ficos
                    """)
            
            # Event handlers (preservados y extendidos)
            init_btn.click(
                fn=self.initialize_service,
                outputs=status_output
            )
            
            reindex_btn.click(
                fn=self.reindex_documents,
                outputs=status_output
            )
            
            status_btn.click(
                fn=self.get_system_status,
                outputs=detailed_status
            )
            
            # Event handler adicional para modo agentic
            if self.is_agentic:
                toggle_btn.click(
                    fn=self.toggle_agentic_mode,
                    outputs=status_output
                )
        
        return interface
    
    def launch(self, **kwargs):
        """Lanza la aplicaci√≥n (m√©todo preservado)"""
        interface = self.create_interface()
        
        # Configuraci√≥n por defecto
        launch_kwargs = {
            'server_port': settings.server_port,
            'share': settings.share_gradio,
            'show_error': True,
            'quiet': False,
            **kwargs
        }
        
        mode_text = "agentic" if self.is_agentic else "classic"
        logger.info(f"Launching RAG app in {mode_text} mode on port {launch_kwargs['server_port']}")
        interface.launch(**launch_kwargs)

# Funci√≥n de compatibilidad para migraci√≥n gradual
class GradioRAGApp(AgenticGradioApp):
    """
    Alias para mantener compatibilidad con c√≥digo existente.
    Autom√°ticamente usa capacidades agentic si est√°n disponibles.
    """
    
    def __init__(self):
        super().__init__(enable_agentic=True)
        logger.info("GradioRAGApp initialized with agentic capabilities")